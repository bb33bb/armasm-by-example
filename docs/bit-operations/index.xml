<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ARM Assembly By Example</title><link>https://armasm.com/docs/bit-operations/</link><description>Recent content on ARM Assembly By Example</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://armasm.com/docs/bit-operations/index.xml" rel="self" type="application/rss+xml"/><item><title>Signed Numbers</title><link>https://armasm.com/docs/bit-operations/signed-numbers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://armasm.com/docs/bit-operations/signed-numbers/</guid><description>Signed Numbers # You may believe that I have made a mistake &amp;ndash; how could negative numbers appear under the section about &amp;ldquo;Bit Operations&amp;rdquo; and not &amp;ldquo;Arithmetic&amp;rdquo;. It is because the way that the computer understands negative numbers has everything to do with manipulating bits in a certain way and less to do with negative numbers themselves.
If you take the number 210 and write it out in individual bits, it would be 0b11010010.</description></item><item><title>Program 11: All Positivity</title><link>https://armasm.com/docs/bit-operations/positivty/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://armasm.com/docs/bit-operations/positivty/</guid><description>Revisiting the N flag # You learned briefly that the N flag is set if the number, interpreted as signed,
used to set the CPSR is a negative number. You may be surprised to know, that really this flag is a mirror of the most significant bit. No, seriously. It&amp;rsquo;s that simple. Imagine the ARM processor had 8-bit registers as opposed to 32-bit.
Number 8-bit register N set?</description></item><item><title>Exorcise and bicycle orr...</title><link>https://armasm.com/docs/bit-operations/exorcise/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://armasm.com/docs/bit-operations/exorcise/</guid><description>Exorcise and bicycle orr&amp;hellip; # Now that you have started thinking about the individual bits that make up the data that you work with on a daily basis, there are a couple of operations that allow you to do this easily.
AND operation # AND allows you to create a value that displays where both bits are set.
Val 1 Op Val 2 Result 0 AND 0 0 0 AND 1 0 1 AND 1 1 1 AND 0 0 The syntax is:</description></item><item><title>Program 12: Ok, Be Negative</title><link>https://armasm.com/docs/bit-operations/ok-be-negative/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://armasm.com/docs/bit-operations/ok-be-negative/</guid><description>Using XOR for sign detection # With signed integers, the most significant bit will always be 1 if the number is negative. Try XOR-ing two negative numbers in our imaginary 8-bit registers.
0b11110110 -10 XOR 0b11011110 -35 ===================== 0b00101000 ^--- First bit 0 If you take a negative and a positive number, this happens.
0b11110110 -10 XOR 0b00000010 2 ===================== 0b11110100 ^--- First bit 1 This is helpful because the N flag of the CPSR is a mirror of the most significant bit.</description></item><item><title>Program 13: XOR Cipher</title><link>https://armasm.com/docs/bit-operations/xor-cipher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://armasm.com/docs/bit-operations/xor-cipher/</guid><description>Basic Cryptography # Cryptography is an art that has always fascinated me. How do you take a message, encrypt it, and send it to someone else to read without allowing anyone else to read it. With the exclusive OR, you can do basic encryption that is similar to a ROT13 or the little coder wheels that used to be in cereal boxes.1
The way that this works is you first take a message you want to encrypt.</description></item><item><title>Shifting and Rotating</title><link>https://armasm.com/docs/bit-operations/shifting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://armasm.com/docs/bit-operations/shifting/</guid><description>Shifting and Rotating # Shifting and rotating refer to the process of taking the bits of a number and moving them either to the left or the right. The ARM processor has a barrel shifter included in the hardware which allows you to shift the flexible operand2.
Rotating # Rotating is the operation where when bits get to the end of the register, they move to the other side.</description></item><item><title>Program 14: Hex and Love</title><link>https://armasm.com/docs/bit-operations/hex-and-love/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://armasm.com/docs/bit-operations/hex-and-love/</guid><description>Converting decimal to hexadecimal # You know that you can enter numbers as decimal, octal, binary, or hexadecimal. The question is, however, how do you actually change base? Going from binary (base 2) to hexadecimal (base 16) is fairly easy because 2 fits inside of 16. When you go from decimal (base 10) to hexadecimal, you need to get to that intermediate step.
Take the number 200. To visualize the base change better, write 200 in binary.</description></item><item><title>Program 15: The Un-sale</title><link>https://armasm.com/docs/bit-operations/unsale/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://armasm.com/docs/bit-operations/unsale/</guid><description>Multiply by &amp;lt;base&amp;gt; # In decimal, it&amp;rsquo;s really easy to multiply by 10. You just simply add a 0 to the end of the number.
3 * 10 = 30 30 * 10 = 300 Boom. Did you know this works in every base?
0x1 (1) * 16 = 0x10 (16) 0x10 (16) * 16 = 0x100 (256) Boom. You can take this knowledge and combine it with left shifts to multiply by 2 easily.</description></item><item><title>Program 16: 64-bit Math</title><link>https://armasm.com/docs/bit-operations/64-bit-math/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://armasm.com/docs/bit-operations/64-bit-math/</guid><description>Binary long division # If you remember back in middle school (elementary?), long division was one of those things where you probably just though, &amp;ldquo;can&amp;rsquo;t I use a calculator?&amp;rdquo; Can you do this with other bases other than 10? Absolutely. Welcome to long division, binary edition.
It&amp;rsquo;s actually pretty simple. Look at an example of 200/8.
00011001 = 25 __________ 1000 | 11001000 1: 1 2: 11 3: 110 4: 1100 -1000 0100 5: 1001 -1000 0001 6: 10 7: 100 8: 1000 -1000 As opposed to re-inventing the wheel, Ben Eater has a great detailed video explaining how to do this with a computer.</description></item></channel></rss>