<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on ARM Assembly By Example</title><link>/</link><description>Recent content in Introduction on ARM Assembly By Example</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Conditionals</title><link>/docs/branches-and-conditionals/conditionals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/branches-and-conditionals/conditionals/</guid><description>Conditionals # There was a brief mention about the status codes stored in the CPSR. This is when you get to start using them. Because assembly doesn&amp;rsquo;t have the concept of data types, the processor needs to figure out another way to define conditions such as equal, not equal, greater than, less than or equal, etc. It does this by looking at the flags of the CPSR.
Comparison methods # The first thing you need to do is to tell the processor that you want it to update the CPSR.</description></item><item><title>Errors and Tests</title><link>/docs/arithmetic/errors-and-tests/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/arithmetic/errors-and-tests/</guid><description>Errors and Tests # Both of these topics are important and not explicitly covered in this tutorial. However, the sooner you start thinking about them, the better off you will be when you need/want to include them in your program. They are not presented here to give answers, only to make sure you are considering them. Error handling # One of the two things that you miss in this series of exercises is error handling.</description></item><item><title>FPU Overview</title><link>/docs/fpu/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/fpu/overview/</guid><description>FPU Overview # In addition to the core processor, there can exist an optional co-processor that works with floating point numbers. Since the release, this co-processor has become almost synonymous to the NEON co-processor which you will learn about in the next appendix.
Mnemonics # Many of the instructions you used with the core processor exist in the FPU, but they are prefixed with a &amp;lsquo;V&amp;rsquo;. A full list is here.</description></item><item><title>NEON Overview</title><link>/docs/neon/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/neon/overview/</guid><description>NEON Overview # With all of the cool things computers can do these days, this may be one of the most exciting things. Many times in computing you need to do the same operation to a set of data. This could include color correcting pixels on a screen, running a cryptography algorithm, and determining reflection/blur results. For the longest time, processors were limited to calculating these with one instruction that resulted in one data point.</description></item><item><title>Program 17: Add the Arguments</title><link>/docs/working-in-linux/add-the-arguments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/working-in-linux/add-the-arguments/</guid><description>Reading program arguments # The first type of interaction you will learn about is how arguments are passed to a program from the Linux command line. To understand/visualize this, I HIGHLY recommend installing an extension such as GEF for the GNU debugger.
Take one of the programs you have created and start it in GDB. When you do this, set a break point at _start and run it using the command: r arg1 arg2 arg3.</description></item><item><title>Register Overview</title><link>/docs/registers-and-memory/register-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/registers-and-memory/register-overview/</guid><description>Register overview # As mentioned before, the registers are inside the processor and allow the processor to operate on data. The ARM processor can not do calculations or manipulate data directly inside the memory. The ARM processor has 16 32-bit registers (r0-r15).
Sane register usage # While technically you can use every register, some of the registers are reserved for
specific functions.
r0 - r12: General purpose - Use without care of reserved functionality r13: Stack pointer - Address location of stack in memory r14: Link register - Address location of where to return to after branch r15: Program counter - Address location of &amp;ldquo;next&amp;rdquo; operation to perform And then, within the general purpose registers, there are some soft rules.</description></item><item><title>Signed Numbers</title><link>/docs/bit-operations/signed-numbers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/bit-operations/signed-numbers/</guid><description>Signed Numbers # You may believe that I have made a mistake &amp;ndash; how could negative numbers appear under the section about &amp;ldquo;Bit Operations&amp;rdquo; and not &amp;ldquo;Arithmetic&amp;rdquo;. It is because the way that the computer understands negative numbers has everything to do with manipulating bits in a certain way and less to do with negative numbers themselves.
If you take the number 210 and write it out in individual bits, it would be 0b11010010.</description></item><item><title>The Basics</title><link>/docs/getting-to-hello-world/basics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/getting-to-hello-world/basics/</guid><description>The Basics # Dependency Check # The first thing that we need to do is check to make sure that we have all of the correct tools that we need. The below table will tell you the program name, the command to check to make sure that it is installed, and what package includes the tool if it isn&amp;rsquo;t present.
Program Name Check Command Required Package GNU Assembler as --version binutils GNU Linker ld --version binutils GNU Debugger gdb --version gdb Make make --version make Syntax # The first part of writing programs is understanding the syntax of the language.</description></item><item><title>Branches and Loops</title><link>/docs/branches-and-conditionals/branches-and-loops/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/branches-and-conditionals/branches-and-loops/</guid><description>Branches and Loops # Now that you can write conditional code, you need to know how to move around the code in a non-linear manner. Assembly only has one such concept and that is branch. Branch is just like GOTO in languages that support it.
mov r0, #2 @ Move 2 into register 0 loop: add r0, #1 @ Add 1 to r0 b loop @ return to loop label As you can see above, when we branch we will branch to labels.</description></item><item><title>Datatypes</title><link>/docs/arithmetic/datatypes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/arithmetic/datatypes/</guid><description>Datatypes # The string types # The first set of built in data types are the two that you have already learned: ascii and asciz. To review, both ascii and asciz encode ASCII characters to their integer equivalents. The asciz directive adds a null character to the end of the string.
The integer types # In the data section you can also specify integers that will be loaded with the program.</description></item><item><title>Memory Overview</title><link>/docs/registers-and-memory/memory-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/registers-and-memory/memory-overview/</guid><description>Memory overview # When someone says that a computer has &amp;ldquo;memory,&amp;rdquo; it could be a number of things. There are all kinds of media that fall under this category. Any peripheral outside of the processor that stores data can be considered memory. In addition to the RAM, there may be ROM (read only memory), EEPROM (electrically erasable programmable read-only memory), flash drives, disc drives, tape cassettes&amp;hellip; In this series, when we talk about memory, we will always be talking about RAM unless specified otherwise.</description></item><item><title>Program 11: All Positivity</title><link>/docs/bit-operations/positivty/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/bit-operations/positivty/</guid><description>Revisiting the N flag # You learned briefly that the N flag is set if the number, interpreted as signed,
used to set the CPSR is a negative number. You may be surprised to know, that really this flag is a mirror of the most significant bit. No, seriously. It&amp;rsquo;s that simple. Imagine the ARM processor had 8-bit registers as opposed to 32-bit.
Number 8-bit register N set?</description></item><item><title>Program 18: Add the Inputs</title><link>/docs/working-in-linux/add-the-inputs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/working-in-linux/add-the-inputs/</guid><description>Reading input and the docs # As you dig in deeper and deeper into your programming journey, it becomes more and more important to be able to read the docs. As boring and monotonous as that sounds, this is the best way to learn. Start by looking at the table of syscalls that you saw before. You can see that read is #3.
To learn more about the read operation, you can use the man pages by looking at the 2 (syscall) entry.</description></item><item><title>Program 1: Exiting</title><link>/docs/getting-to-hello-world/exiting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/getting-to-hello-world/exiting/</guid><description>While you may wonder why you need to talk about how to exit a program, know that you do. Unlike many higher languages, assembly programs don&amp;rsquo;t gracefully exit when you stop writing code. What happens if you don&amp;rsquo;t exit the program is the the computer will keep reading data in memory past the last opcode. Because you are running in a *nix environment, you will get a segmentation fault as it will drift into memory you don&amp;rsquo;t have access to.</description></item><item><title>Program 20: Here to There</title><link>/docs/fpu/here-to-there/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/fpu/here-to-there/</guid><description>Floating point numbers # How does a floating point number actually work? IEEE 754 is the tech sheet that talks about floating point numbers. For single precision, it says that the layout is:
Sign (+/-) Exponent Fraction bit 31 bits 23-30 bit 0-22 For double precision it is:
Sign (+/-) Exponent Fraction bit 63 bits 52-62 bit 0-51 The sign bit is the easy part.</description></item><item><title>Program 21: Bus Rider</title><link>/docs/neon/bus-rider/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/neon/bus-rider/</guid><description>This is, without a doubt, a simple introductory program to use the NEON co-processor. It has all kinds of uses but I wanted to find something that was both simple and more concrete then &amp;ldquo;LOOK HOW COOL IT IS WHEN WE USE RANDOM NUMBERS TO DO RAY TRACING!!&amp;rdquo; A little backgrounds on matrices first if you don&amp;rsquo;t know how they can be solved.
Matrices # If you think back to linear algebra, you will probably remember a small part where you were working with matrices.</description></item><item><title>Exorcise and bicycle orr...</title><link>/docs/bit-operations/exorcise/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/bit-operations/exorcise/</guid><description>Exorcise and bicycle orr&amp;hellip; # Now that you have started thinking about the individual bits that make up the data that you work with on a daily basis, there are a couple of operations that allow you to do this easily.
AND operation # AND allows you to create a value that displays where both bits are set.
Val 1 Op Val 2 Result 0 AND 0 0 0 AND 1 0 1 AND 1 1 1 AND 0 0 The syntax is:</description></item><item><title>Multiplication</title><link>/docs/arithmetic/multiplication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/arithmetic/multiplication/</guid><description>Multiplication # When a processor does multiplication, it doesn&amp;rsquo;t quite do multiplication in the way you can do it in your head. It uses a process you probably wouldn&amp;rsquo;t think about. In fact, with the ARM processors, every multiply operation takes at least ~4-6 cycles.
MUL operation # The MUL operation is the &amp;ldquo;basic&amp;rdquo; multiplication operation. It takes the format mul Rd, Rn, Rm where Rd is the destination and Rn and Rm are input registers.</description></item><item><title>Program 19: Add the File</title><link>/docs/working-in-linux/add-the-file/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/working-in-linux/add-the-file/</guid><description>Reading more of the docs # For the next exercise, you will use the read call again, but on an actual file and not stdin. In the last example you knew the file descriptor was 0 for stdin. For this, you will need to first open the file in order to get the file descriptor.
When you look at the man page for open (man open 2) you will the following note:</description></item><item><title>Program 2: Hello World</title><link>/docs/getting-to-hello-world/hello-world/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/getting-to-hello-world/hello-world/</guid><description>From the exiting program, you can add a couple more lines before it to actually output the &amp;ldquo;Hello World!&amp;rdquo;
Labels # You have already used the _start: label but what does that actually do? A label simply names a place in the program that you can reference to later. In the data section, it&amp;rsquo;s common to label the beginning part of a piece of data. When this happens, that label and all references to it, will become the same address that points to a place in the data loaded into memory.</description></item><item><title>Program 3: Find the Otter</title><link>/docs/registers-and-memory/find-the-otter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/registers-and-memory/find-the-otter/</guid><description>ADD operation # You will focus on math heavy concepts later, but for now you do need one operator to increment for things like memory addresses and loops. Also, you may have guessed that the ADD opcode adds two numbers. Both of these formats are exactly the same.
add r0, r1, r2 @ Add r1 and r2 and store in r0 add r1, r2 @ Add r1 and r2 and store in r1 STR(-B) operation # STR is the opposite of LDR.</description></item><item><title>Program 5: Hello World Revisited</title><link>/docs/branches-and-conditionals/hello-world-revisited/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/branches-and-conditionals/hello-world-revisited/</guid><description>Including Other Files, Pt. 1 # MACRO directive # Putting everything in one file is great keeping code together, but absolutely awful for more than trivial programs as the number of lines of code grows rapidly. There are two ways you can include code in from other files and this is the first way. Like a keyboard macro, the MACRO directive puts an exact copy of the code at the point of inclusion.</description></item><item><title>Program 12: Ok, Be Negative</title><link>/docs/bit-operations/ok-be-negative/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/bit-operations/ok-be-negative/</guid><description>Using XOR for sign detection # With signed integers, the most significant bit will always be 1 if the number is negative. Try XOR-ing two negative numbers in our imaginary 8-bit registers.
0b11110110 -10 XOR 0b11011110 -35 ===================== 0b00101000 ^--- First bit 0 If you take a negative and a positive number, this happens.
0b11110110 -10 XOR 0b00000010 2 ===================== 0b11110100 ^--- First bit 1 This is helpful because the N flag of the CPSR is a mirror of the most significant bit.</description></item><item><title>Program 4: Memory Copy</title><link>/docs/registers-and-memory/memory-copy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/registers-and-memory/memory-copy/</guid><description>Reserving Space, Pt. 2 # Sometimes (read most of the time) you probably won&amp;rsquo;t know the length of the output or exactly how much space you will need for the program. As opposed to writing a string in memory, you can use the fill directive to reserve space. The syntax is # of data parts to reserve, the size of the space to reserve, and the value to store in that space.</description></item><item><title>Program 6: Sticky Keyboard</title><link>/docs/branches-and-conditionals/sticky-keyboard/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/branches-and-conditionals/sticky-keyboard/</guid><description>Are you tired of adding one all the time to increment memory addresses? What if I told you there was a better way? A way where you didn&amp;rsquo;t need the ADD opcode. A way that allows the processor to work in less cycles?!?!?!? Now for $19.95 I will show you the secret to be more efficient. Or you could just read below.
Incrementing LDR/STR instructions # Offset address # The first method is to alter the address before the LDR or STR operation happens.</description></item><item><title>Program 8: ITOA</title><link>/docs/arithmetic/itoa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/arithmetic/itoa/</guid><description>EQU directive # While you don&amp;rsquo;t have variables in the standard sense, there is one naming thing you can do. You can use the EQU directive to define a read only number.
.equ var1, 128 mov r0, #var1</description></item><item><title>Inspecting Our Program</title><link>/docs/branches-and-conditionals/inspecting-our-program/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/branches-and-conditionals/inspecting-our-program/</guid><description>Inspecting Our Program # There are at least two programs you can use to look at programs and debug. First, compile the following program using the command as -g -o main.o main.s. What the -g flag will do is add debug symbols to the executable. The linker command will be the same as before. (ld -o main main.o)
.global_start _start: mov r4, #2 @ load 2 into r4 add r4, #6 @ add 6 to r4 Object dump # The first tool you can use is objdump.</description></item><item><title>Program 13: XOR Cipher</title><link>/docs/bit-operations/xor-cipher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/bit-operations/xor-cipher/</guid><description>Basic Cryptography # Cryptography is an art that has always fascinated me. How do you take a message, encrypt it, and send it to someone else to read without allowing anyone else to read it. With the exclusive OR, you can do basic encryption that is similar to a ROT13 or the little coder wheels that used to be in cereal boxes.1
The way that this works is you first take a message you want to encrypt.</description></item><item><title>The Stack</title><link>/docs/arithmetic/the-stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/arithmetic/the-stack/</guid><description>The Stack # We spoke before about the different places that data can live, now we will dive into how those places are used. Hard Drives/SSDs are use to store data &amp;ldquo;long term.&amp;rdquo; And by long term I mean generally longer than the invocation of a program. It&amp;rsquo;s also used for files that are exceptionally large.
Within the RAM, there are two primary areas: the stack and the heap. These concepts are constructs of the operating system.</description></item><item><title>Program 7: Cloning Myself</title><link>/docs/branches-and-conditionals/cloning-myself/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/branches-and-conditionals/cloning-myself/</guid><description>Make files # In the current day of project builders, scaffolding, runners, and so forth one may forget that there was a time, not so long ago, that you could just use a program installed on almost every *nix operating system. That program is make.
The syntax for a make file is very simple.
target: prerequisites &amp;lt;TAB&amp;gt;steps to build The first part is defining which files you need for the program.</description></item><item><title>Program 9: Factorials</title><link>/docs/arithmetic/factorial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/arithmetic/factorial/</guid><description>.stack-grid { display: grid; grid-template-columns: [fn] 1fr [frame] 1fr [label] 1fr [end]; border: 2px solid black; } .stack-fn { padding-left: 4px; grid-column: fn / frame; } .frame { grid-column: frame / label; height: 32px; border-width: 0px 2px 2px 2px; border-color: black; border-style: solid; padding-left: 4px; line-height: 32px; } .stack-label { grid-column: label / end; padding-lect: 4px; } .frame:last-of-type { border-bottom-width: 0px; } Including Other Files, Pt. 2 # In addition to using macros, we can use instructions in compile object files.</description></item><item><title>Shifting and Rotating</title><link>/docs/bit-operations/shifting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/bit-operations/shifting/</guid><description>Shifting and Rotating # Shifting and rotating refer to the process of taking the bits of a number and moving them either to the left or the right. The ARM processor has a barrel shifter included in the hardware which allows you to shift the flexible operand2.
Rotating # Rotating is the operation where when bits get to the end of the register, they move to the other side.</description></item><item><title>Program 10: Sum of Squares</title><link>/docs/arithmetic/sum-of-squares/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/arithmetic/sum-of-squares/</guid><description/></item><item><title>Program 14: Hex and Love</title><link>/docs/bit-operations/hex-and-love/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/bit-operations/hex-and-love/</guid><description>Converting decimal to hexadecimal # You know that you can enter numbers as decimal, octal, binary, or hexadecimal. The question is, however, how do you actually change base? Going from binary (base 2) to hexadecimal (base 16) is fairly easy because 2 fits inside of 16. When you go from decimal (base 10) to hexadecimal, you need to get to that intermediate step.
Take the number 200. To visualize the base change better, write 200 in binary.</description></item><item><title>Program 15: The Un-sale</title><link>/docs/bit-operations/unsale/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/bit-operations/unsale/</guid><description>Multiply by &amp;lt;base&amp;gt; # In decimal, it&amp;rsquo;s really easy to multiply by 10. You just simply add a 0 to the end of the number.
3 * 10 = 30 30 * 10 = 300 Boom. Did you know this works in every base?
0x1 (1) * 16 = 0x10 (16) 0x10 (16) * 16 = 0x100 (256) Boom. You can take this knowledge and combine it with left shifts to multiply by 2 easily.</description></item><item><title>Program 16: 64-bit Math</title><link>/docs/bit-operations/64-bit-math/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/bit-operations/64-bit-math/</guid><description>Binary long division # If you remember back in middle school (elementary?), long division was one of those things where you probably just though, &amp;ldquo;can&amp;rsquo;t I use a calculator?&amp;rdquo; Can you do this with other bases other than 10? Absolutely. Welcome to long division, binary edition.
It&amp;rsquo;s actually pretty simple. Look at an example of 200/8.
00011001 = 25 __________ 1000 | 11001000 1: 1 2: 11 3: 110 4: 1100 -1000 0100 5: 1001 -1000 0001 6: 10 7: 100 8: 1000 -1000 As opposed to re-inventing the wheel, Ben Eater has a great detailed video explaining how to do this with a computer.</description></item></channel></rss>